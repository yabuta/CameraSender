#include "cv.h"
#include "highgui.h"
#include "ctype.h"
#include <opencv2/highgui/highgui.hpp>
#include <unistd.h>
#include <iostream>
#include <stdio.h>
#include <pthread.h>
#include "clientClass.h"

#ifndef CAPTURE_H
#define CAPTURE_H

class ThreadClass {
protected:
  pthread_t thread_handler;      // スレッドハンドラ
  pthread_mutex_t mutex; // ミューテックス(排他処理で優先権を決めるやつ)

public:
  ThreadClass(){
  }

  // ランチャ
  //
  static void* executeLauncher(void* args){
    std::cout << "executeLauncher" << std::endl;
    // 引数に渡されたインスタンスを無理やりキャストして、インスタンスメソッドを実行
    reinterpret_cast<ThreadClass*>(args)->execute();
    return (void*)NULL;
  }

  // スレッド開始
  void threadStart(){
    if ((this->thread_handler) == NULL){
      std::cout << "threadStart" << std::endl;
      pthread_mutex_init(&(this->mutex), NULL); // ミューテックスの初期化
      pthread_create(                           // スレッドの生成
		     &(this->thread_handler),
		     NULL,
		     &ThreadClass::executeLauncher,         // スレッドにできるのは、static なメソッドや関数のみ
		     this
						);
    }
  }

  // スレッドで実行したいインスタンスメソッド
  //
  void execute(){
    run();
  }

  virtual void run(){
    while(1){
      pthread_testcancel();                 // キャンセル要求が来ていたらここで終了
      pthread_mutex_lock(&(this->mutex));   // 優先権を保持するまで待機
      printf("test\n");
      pthread_mutex_unlock(&(this->mutex)); // 優先権を破棄
      sleep(1);
    }
  }

  // デストラクタ
  // * 終了時に、スレッドにキャンセル要求を投げる
  //
  virtual ~ThreadClass(){
    std::cout << "destructor start" << std::endl;
    pthread_cancel(this->thread_handler);     // スレッドにキャンセル要求を投げる
    pthread_join(this->thread_handler, NULL); // スレッドが終了するまで待機
    std::cout << "destructor end" << std::endl;
  }
};

class SendThread : public ThreadClass{

public:

  cv::Mat frame;

  SendThread(){
  }

  ~SendThread(){
  }

  // data に値を挿入
  // * execute が優先権を保持している間は待機する
  //
  void setData(cv::Mat fr){
    pthread_mutex_lock(&(this->mutex));   // 優先権を保持するまで待機
    frame = fr.clone();
    pthread_mutex_unlock(&(this->mutex)); // 優先権を破棄
  }
  cv::Mat getData(){ return frame; }


  void run(){

    vector<uchar> buff;
    vector<int> param;
    param.push_back(CV_IMWRITE_JPEG_QUALITY);
    param.push_back(95);

    string LOCALHOST="127.0.0.1";//ローカルホストのIPアドレス
    int PORT=12345;//ポート番号

    while(1){
      pthread_testcancel();                 // キャンセル要求が来ていたらここで終了
      TcpClient client;
      if(!client.Init(LOCALHOST,PORT)){
	perror("connect server is failed.\n");
	return;
      }

      pthread_mutex_lock(&(this->mutex));   // 優先権を保持するまで待機
      cv::imencode(".jpg",frame,buff,param);
      pthread_mutex_unlock(&(this->mutex)); // 優先権を破棄
      
      vector<char> data;
      vector<uchar>::iterator iterator = buff.begin(); 
      while(iterator != buff.end()){
	data.push_back(static_cast<char>(*iterator));
	iterator++;
      }
      
      printf("data size is %lu\n",data.size());
      int nSend=client.Write(data);//データ受信
      
      printf("send size : %d\n",nSend);

    }
  }

};

class CaptureThread : public ThreadClass{

 private:
  cv::VideoCapture cap;
  
 public:
  CaptureThread(){
  }

  ~CaptureThread(){
  }
  
  void run(){

    //CaptureThread *ct = new CaptureThread();
    int camera_id = 0;
    cv::VideoCapture cap(camera_id);
    if(!cap.isOpened()){
      perror("cameara open error.\n");
      return;
    }

    cv::Mat frame;
    cap.set(CV_CAP_PROP_FPS, 30.0);
    cv::namedWindow("capture",cv::WINDOW_AUTOSIZE);

    while(1){
      pthread_testcancel();                 // キャンセル要求が来ていたらここで終了
      cap >> frame;
      if(frame.empty()) break;
  
      //st->setData(frame);
    
      cv::imshow("capture",frame);
      if(cv::waitKey(30) >= 0) break;
    
    }

    /*
      SendThread *st = new SendThread();

      int camera_id = 0;
      cv::VideoCapture cap(camera_id);
      ostringstream oss;
      cv::Mat frame;
      if(!cap.isOpened()){
      perror("cameara open error.\n");
      return;
      }

      cap.set(CV_CAP_PROP_FPS, 30.0);
      cv::namedWindow("capture",cv::WINDOW_AUTOSIZE);

      st->threadStart();

      while(1){
      pthread_testcancel();                 // キャンセル要求が来ていたらここで終了
      cap >> frame;
      if(frame.empty()) break;

      st->setData(frame);

      cv::imshow("capture",frame);
      if(cv::waitKey(30) >= 0) break;

      }

      delete st;
    */    
  }

  void setCap(cv::VideoCapture cp){
    cap = cp;
  }

};

#endif



